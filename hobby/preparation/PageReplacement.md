# 操作系统 - 页面置换算法

## 页面置换算法
地址映射过程中，若在页面中发现所需要的访问的页面不在内存中，则产生缺页中断。当发生缺页中断时，如果操作系统中没有闲置页面，则必须在内存中选择一个页面将其移出内存，以便于为即将调入的页面让出空间

### 最佳置换算法（OPT）
从内存中移出再也不需要的页面，如无这样的页面存在，则选择最长时间不需要访问的页面。即选择的淘汰页面是以后永不使用的或者是在最长时间内不在被访问的页面。这样可以保证获得最低的缺页率

### 先进先出置换算法（FIFO）
最简单的页面置换算法。当需要淘汰一个页面时，总是选择驻留在内存时间最长的页面进行淘汰。即先进入内存的页面先进行淘汰。理由为：早调入内存的页面不再使用的可能性最大

### 最近最少使用置换算法（LFU）
基于如果一个数据在最近一段时间内使用次数很少，那么在将来一段时间内被使用的可能性也很小的思路

### 最近最久未使用置换算法（LRU）
基于如果一个数据在最近一段时间内没有被访问到，那么在将来他被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰

### 时钟（clock）置换算法
LRU 算法的性能最接近 OPT 算法，但实现起来较为复杂，且开销大。clock 置换算法是LRU的一种变形，在接近LRU的性能上降低了LRU置换算法的开销

### Linux 的页面置换算法
Linux 区分四种不同的页面：不可回收、可交换、可同步、可丢弃
* 不可回收：保留和锁定在内存中的页面以及内核的状态栈等
* 可交换：必须在回收之前写回交换区或分页磁盘分区
* 可同步：若为藏页面，必须要先写回
* 可丢弃：可以被立刻回收的页面

Linux 并没有在缺页中断产生的时候才进行页面回收。Linux 有一个守护进程 kswapd，比较每个内存区域的高低水位来检测是否具有足够的空闲页面使用。每次运行时，仅有一个确定数量的页面被回收。该阙值受限，控制I/O压力

每次执行回收，先回收容易的，再处理难的。回收的页面会加入到空闲链表中

算法是一种改进的LRU算法，维护两组标记；活动/非活动和是否被引用。第一轮扫描清楚引用位，如果第二轮运行确定被引用，就提升一个不太可能回收的状态，否则将该页面移动到一个更可能被回收的状态

处于非活动列表的页面，自从上次检查未被引用过，因而是移除的最佳选择。被引用过但不活跃的页面同样会被考虑回收，是因为一些页面是守护进程访问的，可能很长时间不再使用
此外，内存管理还有一个守护进程pdflush，会定时醒来，写回脏页面；或者可用内存下降到一定水平后被内核唤醒
